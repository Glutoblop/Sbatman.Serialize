#region Usings

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;

#endregion

namespace Sbatman.Serialize
{
    /// <summary>
    ///     The Packet class is a light class that is used for serialising and deserialising data.
    /// </summary>
    public class Packet : IDisposable
    {
        /// <summary>
        ///     This is the initial size of the internal byte array size of the packet
        /// </summary>
        private const int INITAL_DATA_SIZE = 128;

        /// <summary>
        ///     This 4 byte sequence is used to improve start of packet regognition, it isnt the sole descriptor of the packet start
        ///     as this would possibly cause issues with packets with byte sequences within them that happened to contains this.
        /// </summary>
        public static readonly byte[] PacketStart = { 0, 48, 21, 0 };

        /// <summary>
        ///     The type id of the packet
        /// </summary>
        public readonly ushort Type;

        /// <summary>
        ///     The internal data array of the packet
        /// </summary>
        protected byte[] _Data;

        /// <summary>
        ///     The current position in the internal data array
        /// </summary>
        protected uint _DataPos;

        /// <summary>
        ///     Whether the packet is disposed
        /// </summary>
        protected bool _Disposed;

        /// <summary>
        ///     A copy of all the objects packed in this packet
        /// </summary>
        protected List<object> _PacketObjects;

        /// <summary>
        ///     The number of paramerters that are stored in the packet
        /// </summary>
        protected ushort _ParamCount;

        /// <summary>
        ///     A temp copy of the byte array generated by this packet, this is used as a cache for packets with multiple targets, this will be cleared by a number of interactions with the packet
        /// </summary>
        protected byte[] _ReturnByteArray;

        

        private static readonly Dictionary<Type, Action<object, byte[], int>> _GetBytesMethods = new Dictionary<Type, Action<object, byte[], int>>
        {
            {typeof(double),(obj, data, datpos)=>{ BitConverter.GetBytes((double)obj).CopyTo(data, datpos); }},
            {typeof(float),(obj, data, datpos)=>{ BitConverter.GetBytes((float)obj).CopyTo(data, datpos); }},
            {typeof(int),(obj, data, datpos)=>{ BitConverter.GetBytes((int)obj).CopyTo(data, datpos); }},
            {typeof(bool),(obj, data, datpos)=>{ BitConverter.GetBytes((bool)obj).CopyTo(data, datpos); }},
            {typeof(long),(obj, data, datpos)=>{ BitConverter.GetBytes((long)obj).CopyTo(data, datpos); }},
            {typeof(ulong),(obj, data, datpos)=>{ BitConverter.GetBytes((ulong)obj).CopyTo(data, datpos); }},
            {typeof(short),(obj, data, datpos)=>{ BitConverter.GetBytes((short)obj).CopyTo(data, datpos); }},
            {typeof(ushort),(obj, data, datpos)=>{ BitConverter.GetBytes((ushort)obj).CopyTo(data, datpos); }},
            {typeof(uint),(obj, data, datpos)=>{ BitConverter.GetBytes((uint)obj).CopyTo(data, datpos); }},
            {typeof(string),(obj, data, datpos)=>{ Encoding.UTF8.GetBytes((string)obj).CopyTo(data, datpos ); }},
            {typeof(byte[]),(obj, data, datpos)=>{ ((byte[])obj).CopyTo(data, datpos ); }},
            {typeof(decimal),(obj, data, datpos)=>
            {
                int[] sections = decimal.GetBits((decimal)obj);
                for (int i = 0; i < 4; i++) BitConverter.GetBytes(sections[i]).CopyTo(data, datpos + (i * 4));
            }}
        };

        /// <summary>
        ///     Creates a new packet with the specified type id
        /// </summary>
        /// <param name="type">The packets type ID</param>
        /// <param name="internalDataArraySize">The initial size of the packets internal data array, defaults to INITAL_DATA_SIZE </param>
        public Packet(ushort type, int internalDataArraySize = INITAL_DATA_SIZE)
        {
            Type = type;
            _Data = new byte[internalDataArraySize];
        }

        /// <summary>
        ///     Disposes the packet, destroying all internals, buffers and caches, fails silently if the packet is already disposed
        /// </summary>
        public void Dispose()
        {
            _ReturnByteArray = null;
            if (_Disposed) return;
            _Disposed = true;
            if (_PacketObjects != null)
            {
                _PacketObjects.Clear();
                _PacketObjects = null;
            }
            _Data = null;
        }

        /// <summary>
        ///     Creates a deep copy of this packet
        /// </summary>
        /// <returns></returns>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public Packet Copy()
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            Packet p = new Packet(Type)
            {
                _Data = new byte[_Data.Length]
            };
            _Data.CopyTo(p._Data, 0);
            p._DataPos = _DataPos;
            if (_PacketObjects != null) p._PacketObjects = new List<object>(_PacketObjects);
            p._ParamCount = _ParamCount;
            p._ReturnByteArray = _ReturnByteArray;
            return p;
        }

        /// <summary>
        ///     Adds a byte array to the packet
        /// </summary>
        /// <param name="byteArray">The bytearray to add</param>
        /// <param name="compress">Whether or not to compress the bytearray, potentially saving large quantitys of badwidth at increased cpu cost</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(byte[] byteArray, bool compress=false)
        {
            if (compress) byteArray = Compress(byteArray);
            AddInternal(byteArray, compress ? ParamTypes.COMPRESSED_BYTE_PACKET : ParamTypes.BYTE_PACKET, (ushort)byteArray.Length);
        }

        /// <summary>
        ///     Adds a double to the packet
        /// </summary>
        /// <param name="d">The double to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(double d)
        {
            AddInternal(d, ParamTypes.DOUBLE, 8);
        }

        /// <summary>
        ///     Adds a float to the packet
        /// </summary>
        /// <param name="f">The float to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(float f)
        {
            AddInternal(f, ParamTypes.FLOAT, 4);
        }

        /// <summary>
        ///     Adds a boolean to the packet
        /// </summary>
        /// <param name="b">The bool to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(bool b)
        {
            AddInternal(b, ParamTypes.BOOL, 1);
        }

        /// <summary>
        ///     Adds a long to the packet
        /// </summary>
        /// <param name="l">The long to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(long l)
        {
            AddInternal(l, ParamTypes.INT64, 8);
        }

        /// <summary>
        ///     Adds an int32 to the packet
        /// </summary>
        /// <param name="i">The int 32 to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(int i)
        {
            AddInternal(i, ParamTypes.INT32, 4);
        }

        /// <summary>
        ///     Adds an int64 to the packet
        /// </summary>
        /// <param name="i">The int64 to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(ulong i)
        {
            AddInternal(i, ParamTypes.UINT64, 8);
        }

        /// <summary>
        ///     Adds an Int16 to the packet
        /// </summary>
        /// <param name="i">The int16 to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(short i)
        {
            AddInternal(i, ParamTypes.INT16, 2);
        }

        /// <summary>
        ///     Adds an Int16 to the packet
        /// </summary>
        /// <param name="i">The int16 to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(ushort i)
        {
            AddInternal(i, ParamTypes.UINT16, 2);
        }

        /// <summary>
        ///     Adds a Uint32 to the packet
        /// </summary>
        /// <param name="u">The uint32 to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(uint u)
        {
            AddInternal(u, ParamTypes.UINT32, 4);
        }

        /// <summary>
        ///     Adds a decimal to the packet
        /// </summary>
        /// <param name="d">The decimal to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(decimal d)
        {
            AddInternal(d, ParamTypes.DECIMAL, 16);
        }

        /// <summary>
        ///     Adds a UTF8 String to the packet
        /// </summary>
        /// <param name="s">The String to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public void Add(string s)
        {
            AddInternal(s, ParamTypes.UTF8_STRING, (ushort)Encoding.UTF8.GetByteCount(s), true);
        }

        /// <summary>
        /// Adds a list of Doubles to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<double> list)
        {
            AddToListInternal(list, ParamTypes.DOUBLE, 8);
        }

        /// <summary>
        /// Adds a list of floats to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<float> list)
        {
            AddToListInternal(list, ParamTypes.FLOAT, 4);
        }

        /// <summary>
        /// Adds a list of Int32s to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<int> list)
        {
            AddToListInternal(list, ParamTypes.INT32, 4);
        }

        /// <summary>
        /// Adds a list of bool's to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<bool> list)
        {
            AddToListInternal(list, ParamTypes.BOOL, 1);
        }

        /// <summary>
        /// Adds a list of Int64s to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<long> list)
        {
            AddToListInternal(list, ParamTypes.INT64, 8);
        }


        /// <summary>
        /// Adds a list of Decimals to the packet
        /// </summary>
        /// <param name="list">The list of doubles to add</param>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        /// <exception cref="ArgumentOutOfRangeException">Will throw if list is Null, empty or has more than UInt16.MaxValue elements</exception>
        public void AddList(List<decimal> list)
        {
            AddToListInternal(list, ParamTypes.DECIMAL, 16);
        }

        private void AddToListInternal<T>(List<T> list, ParamTypes typeMarker, ushort elementSize)
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            if (list == null || list.Count == 0 || list.Count > ushort.MaxValue) throw new ArgumentOutOfRangeException("list", "Null, empty and > UInt16.MaxValue element lists cannot be added");
            _ReturnByteArray = null;
            int byteLength = 3 + (elementSize * list.Count);
            while (_DataPos + byteLength >= _Data.Length) ExpandDataArray();
            _Data[_DataPos++] = (byte)(((byte)typeMarker) | 128);
            BitConverter.GetBytes((ushort)list.Count).CopyTo(_Data, (int)_DataPos);
            _DataPos += 2;
            foreach (T f in list)
            {
                _GetBytesMethods[typeof(T)](f, _Data, (int)_DataPos);
                _DataPos += elementSize;
            }
            _ParamCount++;
        }

        private void AddInternal<T>(T value, ParamTypes typeMarker, ushort elementSize, bool specifySize = false)
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            _ReturnByteArray = null;
            while (_DataPos + elementSize + 1 >= _Data.Length) ExpandDataArray();
            _Data[_DataPos++] = (byte)(typeMarker);
            if (specifySize)
            {
                BitConverter.GetBytes(elementSize).CopyTo(_Data, (int)_DataPos);
                _DataPos += 4;
            }
            _GetBytesMethods[typeof(T)](value, _Data, (int)_DataPos);
            _DataPos += elementSize;
            _ParamCount++;
        }

        /// <summary>
        ///     Converts the back to a bytearray
        /// </summary>
        /// <returns>A byte array representing the packet</returns>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public byte[] ToByteArray()
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            if (_ReturnByteArray != null) return _ReturnByteArray;
            _ReturnByteArray = new byte[12 + _DataPos];
            PacketStart.CopyTo(_ReturnByteArray, 0);
            BitConverter.GetBytes(_ParamCount).CopyTo(_ReturnByteArray, 4);
            BitConverter.GetBytes(12 + _DataPos).CopyTo(_ReturnByteArray, 6);
            BitConverter.GetBytes(Type).CopyTo(_ReturnByteArray, 10);
            Array.Copy(_Data, 0, _ReturnByteArray, 12, (int)_DataPos);
            return _ReturnByteArray;
        }

        /// <summary>
        ///     Returns the list of objects within this packet
        /// </summary>
        /// <returns>An array of the contained objects</returns>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        public object[] GetObjects()
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            return _PacketObjects.ToArray();
        }

        /// <summary>
        ///     Ensures the packet bojects array correctly represents the objects that should be within this packet
        /// </summary>
        /// <exception cref="ObjectDisposedException">Will throw if packet is disposed</exception>
        protected void UpdateObjects()
        {
            if (_Disposed) throw new ObjectDisposedException(ToString());
            if (_PacketObjects != null)
            {
                _PacketObjects.Clear();
                _PacketObjects = null;
            }
            _PacketObjects = new List<object>(_ParamCount);
            int bytepos = 0;
            for (int x = 0; x < _ParamCount; x++)
            {
                bytepos = (_Data[bytepos] & 128) > 0 ? UnpackList(bytepos) : UnpackValue(bytepos);
            }
        }

        private int UnpackList(int bytepos)
        {
            switch ((ParamTypes)(_Data[bytepos++] & ~128))
            {
                case ParamTypes.DOUBLE:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<double> returnList = new List<double>(listLength);
                        for (int x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToDouble(_Data, bytepos));
                            bytepos += 8;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.FLOAT:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<float> returnList = new List<float>(listLength);
                        for (int x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToSingle(_Data, bytepos));
                            bytepos += 4;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.INT32:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<int> returnList = new List<int>(listLength);
                        for (int x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToInt32(_Data, bytepos));
                            bytepos += 4;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.BOOL:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<bool> returnList = new List<bool>(listLength);
                        for (int x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToBoolean(_Data, bytepos));
                            bytepos += 1;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.INT64:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<long> returnList = new List<long>(listLength);
                        for (var x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToInt64(_Data, bytepos));
                            bytepos += 8;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                //case ParamTypes.BYTE_PACKET:
                //    {
                //        byte[] data = new byte[BitConverter.ToInt32(_Data, bytepos)];
                //        bytepos += 4;
                //        Array.Copy(_Data, bytepos, data, 0, data.Length);
                //        _PacketObjects.Add(data);
                //        bytepos += data.Length;
                //    }
                //    break;
                case ParamTypes.UINT32:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<uint> returnList = new List<uint>(listLength);
                        for (var x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToUInt32(_Data, bytepos));
                            bytepos += 4;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.UINT64:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<ulong> returnList = new List<ulong>(listLength);
                        for (var x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToUInt64(_Data, bytepos));
                            bytepos += 8;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                case ParamTypes.INT16:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<ushort> returnList = new List<ushort>(listLength);
                        for (var x = 0; x < listLength; x++)
                        {
                            returnList.Add(BitConverter.ToUInt16(_Data, bytepos));
                            bytepos += 2;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                //case ParamTypes.UTF8_STRING:
                //    {
                //        byte[] data = new byte[BitConverter.ToInt32(_Data, bytepos)];
                //        bytepos += 4;
                //        Array.Copy(_Data, bytepos, data, 0, data.Length);
                //        _PacketObjects.Add(Encoding.UTF8.GetString(data, 0, data.Length));
                //        bytepos += data.Length;
                //    }
                //    break;
                case ParamTypes.DECIMAL:
                    {
                        ushort listLength = BitConverter.ToUInt16(_Data, bytepos);
                        bytepos += 2;
                        List<decimal> returnList = new List<decimal>(listLength);
                        for (var x = 0; x < listLength; x++)
                        {
                            int[] bits = new int[4];
                            for (int i = 0; i < 4; i++) bits[i] = BitConverter.ToInt32(_Data, bytepos + (i * 4));
                            returnList.Add(new decimal(bits));
                           
                            bytepos += 16;
                        }
                        _PacketObjects.Add(returnList);
                    }
                    break;
                //case ParamTypes.COMPRESSED_BYTE_PACKET:
                //    byte[] data2 = new byte[BitConverter.ToInt32(_Data, bytepos)];
                //    bytepos += 4;
                //    Array.Copy(_Data, bytepos, data2, 0, data2.Length);
                //    _PacketObjects.Add(Uncompress(data2));
                //    bytepos += data2.Length;

                //    break;
                default:
                    throw new PacketCorruptException("An internal unpacking error occured, Unknown internal data type present");
            }
            return bytepos;
        }

        private int UnpackValue(int bytepos)
        {
            switch ((ParamTypes)_Data[bytepos++])
            {
                case ParamTypes.DOUBLE:
                    {
                        _PacketObjects.Add(BitConverter.ToDouble(_Data, bytepos));
                        bytepos += 8;
                    }
                    break;
                case ParamTypes.FLOAT:
                    {
                        _PacketObjects.Add(BitConverter.ToSingle(_Data, bytepos));
                        bytepos += 4;
                    }
                    break;
                case ParamTypes.INT32:
                    {
                        _PacketObjects.Add(BitConverter.ToInt32(_Data, bytepos));
                        bytepos += 4;
                    }
                    break;
                case ParamTypes.BOOL:
                    {
                        _PacketObjects.Add(BitConverter.ToBoolean(_Data, bytepos));
                        bytepos += 1;
                    }
                    break;
                case ParamTypes.INT64:
                    {
                        _PacketObjects.Add(BitConverter.ToInt64(_Data, bytepos));
                        bytepos += 8;
                    }
                    break;
                case ParamTypes.BYTE_PACKET:
                    {
                        byte[] data = new byte[BitConverter.ToInt32(_Data, bytepos)];
                        bytepos += 4;
                        Array.Copy(_Data, bytepos, data, 0, data.Length);
                        _PacketObjects.Add(data);
                        bytepos += data.Length;
                    }
                    break;
                case ParamTypes.UINT32:
                    {
                        _PacketObjects.Add(BitConverter.ToUInt32(_Data, bytepos));
                        bytepos += 4;
                    }
                    break;
                case ParamTypes.UINT64:
                    {
                        _PacketObjects.Add(BitConverter.ToUInt64(_Data, bytepos));
                        bytepos += 8;
                    }
                    break;
                case ParamTypes.INT16:
                    {
                        _PacketObjects.Add(BitConverter.ToInt16(_Data, bytepos));
                        bytepos += 2;
                    }
                    break;
                case ParamTypes.UTF8_STRING:
                    {
                        byte[] data = new byte[BitConverter.ToInt32(_Data, bytepos)];
                        bytepos += 4;
                        Array.Copy(_Data, bytepos, data, 0, data.Length);
                        _PacketObjects.Add(Encoding.UTF8.GetString(data, 0, data.Length));
                        bytepos += data.Length;
                    }
                    break;
                case ParamTypes.DECIMAL:
                    {
                        int[] bits = new int[4];
                        for (int i = 0; i < 4; i++) bits[i] = BitConverter.ToInt32(_Data, bytepos + (i * 4));
                        _PacketObjects.Add(new decimal(bits));
                        bytepos += 16;
                    }
                    break;
                case ParamTypes.COMPRESSED_BYTE_PACKET:
                    byte[] data2 = new byte[BitConverter.ToInt32(_Data, bytepos)];
                    bytepos += 4;
                    Array.Copy(_Data, bytepos, data2, 0, data2.Length);
                    _PacketObjects.Add(Uncompress(data2));
                    bytepos += data2.Length;

                    break;
                default:
                    throw new PacketCorruptException("An internal unpacking error occured, Unknown internal data type present");
            }
            return bytepos;
        }

        /// <summary>
        ///     Increases the size of the internal data array
        /// </summary>
        protected void ExpandDataArray()
        {
            try
            {
                _ReturnByteArray = null;
                byte[] newData = new byte[_Data.Length * 2];
                _Data.CopyTo(newData, 0);
                _Data = newData;
            }
            catch (OutOfMemoryException e)
            {
                throw new OutOfMemoryException("The internal packet data array failed to expand, Too much data allocated", e);
            }
        }

        /// <summary>
        ///     An enum containing supported types
        /// </summary>
        protected enum ParamTypes
        {
            FLOAT,
            DOUBLE,
            INT16,
            UINT16,
            INT32,
            UINT32,
            INT64,
            UINT64,
            BOOL,
            BYTE_PACKET,
            UTF8_STRING,
            COMPRESSED_BYTE_PACKET,
            DECIMAL,
        };

        /// <summary>
        ///     Converts a byte array to a packet
        /// </summary>
        /// <param name="data">the byte array to convery</param>
        /// <returns>Returns a packet build from a byte array</returns>
        public static Packet FromByteArray(byte[] data)
        {
            Packet returnPacket = new Packet(BitConverter.ToUInt16(data, 10))
            {
                _ParamCount = BitConverter.ToUInt16(data, 4),
                _Data = new byte[BitConverter.ToUInt32(data, 6) - 12]
            };
            returnPacket._DataPos = (uint)returnPacket._Data.Length;
            Array.Copy(data, 12, returnPacket._Data, 0, returnPacket._Data.Length);
            returnPacket.UpdateObjects();
            return returnPacket;
        }

        /// <summary>
        /// Reads a packet from the provided stream
        /// </summary>
        /// <param name="data">The stream from which the packet should be sourced</param>
        /// <returns></returns>
        public static Packet FromStream(Stream data)
        {
            const int PACKET_HEADER_LENGTH = 12;
            byte[] packetHeader = new byte[PACKET_HEADER_LENGTH];
            data.Read(packetHeader, 0, PACKET_HEADER_LENGTH);

            if (!TestForPacketHeader(packetHeader)) throw new NotAPacketException();

            uint remainingPacketLength = BitConverter.ToUInt32(packetHeader, 6);
            byte[] packetData = new byte[PACKET_HEADER_LENGTH + remainingPacketLength];
            data.Read(packetData, PACKET_HEADER_LENGTH, (int)remainingPacketLength);
            Array.Copy(packetHeader, packetData, PACKET_HEADER_LENGTH);

            return FromByteArray(packetData);
        }


        public static byte[] Uncompress(byte[] bytes)
        {
            using (DeflateStream ds = new DeflateStream(new MemoryStream(bytes), CompressionMode.Decompress))
            {
                using (MemoryStream ms = new MemoryStream())
                {
                    ds.CopyTo(ms);
                    return ms.ToArray();
                }
            }
        }

        public static byte[] Compress(byte[] bytes)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                using (DeflateStream ds = new DeflateStream(ms, CompressionMode.Compress))
                {
                    ds.Write(bytes, 0, bytes.Length);
                }
                return ms.ToArray();
            }
        }

        /// <summary>
        /// Returns whether the packet header detected in the array has the correct packet start byte marks
        /// </summary>
        /// <param name="data">The array to test</param>
        /// <returns>True if the array has the correct byte start marks else false</returns>

        private static bool TestForPacketHeader(IList<byte> data)
        {
            return !PacketStart.Where((t, x) => data[x] != t).Any();
        }
    }
}